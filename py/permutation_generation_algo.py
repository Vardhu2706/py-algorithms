# Permutation Generation Algorithm

## 1. Category / Type
"""
- Combinatorial Generation
- Backtracking
"""

## 2. Core Idea / Intuition
"""
The core idea behind permutation generation is to produce all possible arrangements of a given set of elements. The algorithm typically involves fixing each element in turn and recursively generating permutations of the remaining elements. This approach ensures that every possible order is considered exactly once.

The intuition is based on the mathematical concept of permutations, where the order of elements matters. For a set of n elements, there are n! (n factorial) possible permutations, which are generated by systematically exploring all possible orderings.
"""

## 3. Steps / Flow
"""
1. **Recursive Approach**:
    - If the array is empty, return an empty list as there are no permutations.
    - If the array has only one element, return a list containing a single permutation with that element.
    - For each element in the array:
        - Fix the element and recursively generate permutations of the remaining elements.
        - Concatenate the fixed element with each permutation of the remaining elements.
        - Collect all such permutations.
    - Return the complete list of permutations.

2. **Iterative Approach Using Lexicographic Order (Heap's Algorithm)**:
    - Start with the input list sorted in ascending order.
    - Generate the next permutation by finding the largest index i such that array[i] < array[i+1].
    - Find the largest index j such that array[i] < array[j].
    - Swap elements at i and j.
    - Reverse the sequence from i+1 to the end of the array.
    - Repeat until no further permutations are possible.
"""

## 4. Time & Space Complexity
"""
| Best | Average | Worst | Space |
|------|---------|-------|-------|
| O(n!) | O(n!)  | O(n!) | O(n)  |

- Time complexity is O(n!) as there are n! permutations, and each permutation takes O(n) time to generate.
- Space complexity is O(n) for the recursive call stack.
"""

## 5. Use Cases
"""
- Generating all possible orderings in scheduling problems.
- Solving puzzles like the traveling salesman problem.
- Generating test cases where order permutations are important.
- Cryptographic algorithms and key permutation.
"""

## 6. Common Variants
"""
- Generating permutations with repetition allowed.
- Generating permutations of subsets of the input.
- Lexicographic permutation generation (next permutation).
- Iterative permutation generation using Heap's Algorithm.
"""

## 7. Trade-offs
"""
- **Time Complexity**: Generating all permutations is computationally expensive due to factorial growth.
- **Space Complexity**: Recursive solutions use additional stack space, which can lead to stack overflow for large inputs.
- **Iterative vs Recursive**: Recursive solutions are often simpler to implement, but iterative solutions may be more efficient in terms of space.
"""

## 8. Pitfalls / Gotchas
"""
- Handling duplicate elements: Care must be taken to avoid generating duplicate permutations when input contains repeated elements.
- Stack overflow: Recursive solutions can hit stack limits for large input sizes.
- Memory usage: The factorial growth in the number of permutations can lead to high memory usage.
"""

## 9. Classic Problems
"""
- The Traveling Salesman Problem (TSP): Finding the shortest possible route that visits each city and returns to the origin city.
- Generating anagrams: Finding all possible rearrangements of a string's characters.
- Sudoku solving: Permutations are used in some approaches to generate possible number placements.
"""

## 10. Code Implementation (Demo)
def generate_permutations(elements):
    if len(elements) <= 1:
        return [elements]
    
    permutations = []
    for i in range(len(elements)):
        # Fix the first element and generate permutations of the remaining elements
        current = elements[i]
        remaining = elements[:i] + elements[i+1:]
        
        for p in generate_permutations(remaining):
            permutations.append([current] + p)
    
    return permutations

# Example usage:
print(generate_permutations([1, 2, 3]))
